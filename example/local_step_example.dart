import 'dart:convert';
import 'package:openai_toolflow/openai_toolflow.dart';

/// Example demonstrating LocalStep for color variations
/// 
/// This example shows how to mix LLM steps and local computation steps:
/// - Step 1 (LLM): Generate 2 base colors
/// - Steps 2-3 (Local): Generate 4 variations of each base color mathematically
/// - Step 4 (LLM): Use all colors to create a design system
/// 
/// This approach reduces token usage and eliminates LLM hallucinations
/// for deterministic mathematical operations.

void main() async {
  // In a real application, load this from environment variables
  final apiKey = 'your-openai-api-key';

  final config = OpenAIConfig(
    apiKey: apiKey,
    defaultModel: 'gpt-4',
  );

  final steps = [
    // Step 1: Generate base colors using LLM (mock service for example)
    ToolCallStep.fromStepDefinition(BaseColorsStepDefinition()),
    
    // Step 2: Locally compute variations of first base color
    LocalStep.fromStepDefinition(
      ColorVariationsStepDefinition(),
      inputBuilder: (previousResults) {
        final baseColors = previousResults[1].asTyped<BaseColorsOutput>().output;
        return {
          'color': baseColors.colors[0],
          'color_name': 'primary',
        };
      },
    ),
    
    // Step 3: Locally compute variations of second base color
    LocalStep.fromStepDefinition(
      ColorVariationsStepDefinition(),
      inputBuilder: (previousResults) {
        final baseColors = previousResults[1].asTyped<BaseColorsOutput>().output;
        return {
          'color': baseColors.colors[1],
          'color_name': 'secondary',
        };
      },
    ),
  ];

  // Use mock service for this example (replace with real service in production)
  final mockService = MockColorService();
  
  final toolFlow = ToolFlow(
    config: config,
    steps: steps,
    openAiService: mockService,
  );

  print('ðŸŽ¨ Running color variation workflow...\n');
  
  final result = await toolFlow.run(
    input: {'theme': 'professional', 'count': 2},
  );

  // Display results
  print('\nðŸ“Š Results:');
  print('=' * 50);
  
  final baseColors = result.finalResults[1].asTyped<BaseColorsOutput>().output;
  print('\nBase Colors (from LLM):');
  for (final color in baseColors.colors) {
    print('  â€¢ $color');
  }
  
  final variations1 = result.finalResults[2].asTyped<ColorVariationsOutput>().output;
  print('\nPrimary Variations (local computation):');
  print('  Base: ${variations1.baseColor}');
  for (final variation in variations1.variations) {
    print('  â€¢ $variation');
  }
  
  final variations2 = result.finalResults[3].asTyped<ColorVariationsOutput>().output;
  print('\nSecondary Variations (local computation):');
  print('  Base: ${variations2.baseColor}');
  for (final variation in variations2.variations) {
    print('  â€¢ $variation');
  }

  // Display token usage
  print('\nðŸ’° Token Usage:');
  print('=' * 50);
  final tokenUsage = result.finalState['token_usage'] as Map<String, dynamic>;
  print('Total tokens: ${tokenUsage['total_tokens']}');
  print('  (Note: Local steps use 0 tokens, only LLM step consumes tokens)');
  
  // Show per-step breakdown
  for (int i = 1; i < result.finalResults.length; i++) {
    final stepResult = result.finalResults[i];
    final stepName = i == 1 ? 'Base Colors (LLM)' : 'Variations (Local)';
    print('  Step $i ($stepName): ${stepResult.tokenUsage.totalTokens} tokens');
  }
}

// ============================================================================
// Output Types
// ============================================================================

/// Output for base colors generated by LLM
class BaseColorsOutput extends ToolOutput {
  final List<String> colors;

  const BaseColorsOutput({
    required this.colors,
    required super.round,
  }) : super.subclass();

  @override
  Map<String, dynamic> toMap() => {
        '_round': round,
        'colors': colors,
      };

  factory BaseColorsOutput.fromMap(Map<String, dynamic> map, int round) {
    return BaseColorsOutput(
      colors: List<String>.from(map['colors'] ?? []),
      round: round,
    );
  }
}

/// Output for color variations generated locally
class ColorVariationsOutput extends ToolOutput {
  final String baseColor;
  final String colorName;
  final List<String> variations;

  const ColorVariationsOutput({
    required this.baseColor,
    required this.colorName,
    required this.variations,
    required super.round,
  }) : super.subclass();

  @override
  Map<String, dynamic> toMap() => {
        '_round': round,
        'base_color': baseColor,
        'color_name': colorName,
        'variations': variations,
      };

  factory ColorVariationsOutput.fromMap(Map<String, dynamic> map, int round) {
    return ColorVariationsOutput(
      baseColor: map['base_color'] as String? ?? '',
      colorName: map['color_name'] as String? ?? '',
      variations: List<String>.from(map['variations'] ?? []),
      round: round,
    );
  }
}

// ============================================================================
// Step Definitions
// ============================================================================

/// Step definition for generating base colors (LLM)
class BaseColorsStepDefinition extends StepDefinition<BaseColorsOutput> {
  @override
  String get stepName => 'generate_base_colors';

  @override
  OutputSchema get outputSchema => OutputSchema(
        properties: [
          PropertyEntry.array(
            name: 'colors',
            items: PropertyType.string,
          ),
        ],
      );

  @override
  BaseColorsOutput fromMap(Map<String, dynamic> data, int round) {
    return BaseColorsOutput.fromMap(data, round);
  }
}

/// Step definition for generating color variations (Local)
class ColorVariationsStepDefinition extends LocalStepDefinition<ColorVariationsOutput> {
  @override
  String get stepName => 'generate_color_variations';

  @override
  OutputSchema get outputSchema => OutputSchema(
        properties: [
          PropertyEntry.string(name: 'base_color'),
          PropertyEntry.string(name: 'color_name'),
          PropertyEntry.array(
            name: 'variations',
            items: PropertyType.string,
          ),
        ],
      );

  @override
  ColorVariationsOutput fromMap(Map<String, dynamic> data, int round) {
    return ColorVariationsOutput.fromMap(data, round);
  }

  @override
  Future<Map<String, dynamic>> computeFunction(Map<String, dynamic> input) async {
    final baseColor = input['color'] as String? ?? '#000000';
    final colorName = input['color_name'] as String? ?? 'color';
    
    // Generate 4 variations by adjusting brightness
    final variations = _generateColorVariations(baseColor);
    
    return {
      'base_color': baseColor,
      'color_name': colorName,
      'variations': variations,
    };
  }

  /// Generates color variations by adjusting RGB values mathematically
  List<String> _generateColorVariations(String hexColor) {
    // Remove # if present
    final hex = hexColor.replaceAll('#', '');
    
    // Parse RGB values
    final r = int.parse(hex.substring(0, 2), radix: 16);
    final g = int.parse(hex.substring(2, 4), radix: 16);
    final b = int.parse(hex.substring(4, 6), radix: 16);
    
    // Generate 4 variations with different brightness levels
    return [
      _adjustBrightness(r, g, b, 0.7),  // Darker
      _adjustBrightness(r, g, b, 0.85), // Slightly darker
      _adjustBrightness(r, g, b, 1.15), // Slightly lighter
      _adjustBrightness(r, g, b, 1.3),  // Lighter
    ];
  }

  /// Adjusts brightness of RGB color by a factor
  String _adjustBrightness(int r, int g, int b, double factor) {
    final newR = (r * factor).clamp(0, 255).round();
    final newG = (g * factor).clamp(0, 255).round();
    final newB = (b * factor).clamp(0, 255).round();
    
    return '#${newR.toRadixString(16).padLeft(2, '0')}${newG.toRadixString(16).padLeft(2, '0')}${newB.toRadixString(16).padLeft(2, '0')}'.toUpperCase();
  }
}

// ============================================================================
// Mock Service (for demonstration)
// ============================================================================

/// Mock OpenAI service for demonstration purposes
/// In production, use the real DefaultOpenAiToolService
class MockColorService implements OpenAiToolService {
  @override
  Future<ToolCallResponse> executeToolCall(
    ToolCallStep step,
    ToolInput input, {
    List<ToolResult>? includedResults,
    List<ToolResult>? currentStepRetries,
  }) async {
    // Simulate API delay
    await Future.delayed(Duration(milliseconds: 100));
    
    // Generate mock base colors
    return ToolCallResponse(
      output: {
        'colors': ['#3B82F6', '#10B981'], // Blue and Green
      },
      usage: {
        'prompt_tokens': 50,
        'completion_tokens': 30,
        'total_tokens': 80,
      },
    );
  }
}
